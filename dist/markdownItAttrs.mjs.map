{"version":3,"file":"markdownItAttrs.mjs","sources":["../utils.js","../patterns.js","../index.js"],"sourcesContent":["\n/**\n * parse {.class #id key=val} strings\n * @param {string} str: string to parse\n * @param {int} start: where to start parsing (including {)\n * @returns {2d array}: [['key', 'val'], ['class', 'red']]\n */\nfunction getAttrs(str, start, options) {\n  // not tab, line feed, form feed, space, solidus, greater than sign, quotation mark, apostrophe and equals sign\n  const allowedKeyChars = /[^\\t\\n\\f />\"'=]/;\n  const pairSeparator = ' ';\n  const keySeparator = '=';\n  const classChar = '.';\n  const idChar = '#';\n\n  const attrs = [];\n  let key = '';\n  let value = '';\n  let parsingKey = true;\n  let valueInsideQuotes = false;\n\n  // read inside {}\n  // start + left delimiter length to avoid beginning {\n  // breaks when } is found or end of string\n  for (let i = start + options.leftDelimiter.length; i < str.length; i++) {\n    if (str.slice(i, i + options.rightDelimiter.length) === options.rightDelimiter) {\n      if (key !== '') { attrs.push([ key, value ]); }\n      break;\n    }\n    let char_ = str.charAt(i);\n\n    // switch to reading value if equal sign\n    if (char_ === keySeparator && parsingKey) {\n      parsingKey = false;\n      continue;\n    }\n\n    // {.class} {..css-module}\n    if (char_ === classChar && key === '') {\n      if (str.charAt(i + 1) === classChar) {\n        key = 'css-module';\n        i += 1;\n      } else {\n        key = 'class';\n      }\n      parsingKey = false;\n      continue;\n    }\n\n    // {#id}\n    if (char_ === idChar && key === '') {\n      key = 'id';\n      parsingKey = false;\n      continue;\n    }\n\n    // {value=\"inside quotes\"}\n    if (char_ === '\"' && value === '') {\n      valueInsideQuotes = true;\n      continue;\n    }\n    if (char_ === '\"' && valueInsideQuotes) {\n      valueInsideQuotes = false;\n      continue;\n    }\n\n    // read next key/value pair\n    if ((char_ === pairSeparator && !valueInsideQuotes)) {\n      if (key === '') {\n        // beginning or ending space: { .red } vs {.red}\n        continue;\n      }\n      attrs.push([ key, value ]);\n      key = '';\n      value = '';\n      parsingKey = true;\n      continue;\n    }\n\n    // continue if character not allowed\n    if (parsingKey && char_.search(allowedKeyChars) === -1) {\n      continue;\n    }\n\n    // no other conditions met; append to key/value\n    if (parsingKey) {\n      key += char_;\n      continue;\n    }\n    value += char_;\n  }\n\n  if (options.allowedAttributes && options.allowedAttributes.length) {\n    let allowedAttributes = options.allowedAttributes;\n\n    return attrs.filter(function (attrPair) {\n      let attr = attrPair[0];\n\n      function isAllowedAttribute(allowedAttribute) {\n        return (attr === allowedAttribute\n          || (allowedAttribute instanceof RegExp && allowedAttribute.test(attr))\n        );\n      }\n\n      return allowedAttributes.some(isAllowedAttribute);\n    });\n\n  }\n  return attrs;\n}\n\n/**\n * add attributes from [['key', 'val']] list\n * @param {array} attrs: [['key', 'val']]\n * @param {token} token: which token to add attributes\n * @returns token\n */\nfunction addAttrs(attrs, token) {\n  for (let j = 0, l = attrs.length; j < l; ++j) {\n    let key = attrs[j][0];\n    if (key === 'class') {\n      token.attrJoin('class', attrs[j][1]);\n    } else if (key === 'css-module') {\n      token.attrJoin('css-module', attrs[j][1]);\n    } else {\n      token.attrPush(attrs[j]);\n    }\n  }\n  return token;\n}\n\n/**\n * Does string have properly formatted curly?\n *\n * start: '{.a} asdf'\n * middle: 'a{.b}c'\n * end: 'asdf {.a}'\n * only: '{.a}'\n *\n * @param {string} where to expect {} curly. start, middle, end or only.\n * @return {function(string)} Function which testes if string has curly.\n */\nfunction hasDelimiters(where, options) {\n  if (!where) {\n    throw new Error('Parameter `where` not passed. Should be \"start\", \"middle\", \"end\" or \"only\".');\n  }\n\n  /**\n   * @param {string} str\n   * @return {boolean}\n   */\n  return function (str) {\n    // we need minimum three chars, for example {b}\n    let minCurlyLength = options.leftDelimiter.length + 1 + options.rightDelimiter.length;\n    if (!str || typeof str !== 'string' || str.length < minCurlyLength) {\n      return false;\n    }\n\n    function validCurlyLength(curly) {\n      let isClass = curly.charAt(options.leftDelimiter.length) === '.';\n      let isId = curly.charAt(options.leftDelimiter.length) === '#';\n      return (isClass || isId)\n        ? curly.length >= (minCurlyLength + 1)\n        : curly.length >= minCurlyLength;\n    }\n\n    let start, end, slice, nextChar;\n    let rightDelimiterMinimumShift = minCurlyLength - options.rightDelimiter.length;\n    switch (where) {\n    case 'start':\n      // first char should be {, } found in char 2 or more\n      slice = str.slice(0, options.leftDelimiter.length);\n      start = slice === options.leftDelimiter ? 0 : -1;\n      end = start === -1 ? -1 : str.indexOf(options.rightDelimiter, rightDelimiterMinimumShift);\n      // check if next character is not one of the delimiters\n      nextChar = str.charAt(end + options.rightDelimiter.length);\n      if (nextChar && options.rightDelimiter.indexOf(nextChar) !== -1) {\n        end = -1;\n      }\n      break;\n\n    case 'end':\n      // last char should be }\n      start = str.lastIndexOf(options.leftDelimiter);\n      end = start === -1 ? -1 : str.indexOf(options.rightDelimiter, start + rightDelimiterMinimumShift);\n      end = end === str.length - options.rightDelimiter.length ? end : -1;\n      break;\n\n    case 'only':\n      // '{.a}'\n      slice = str.slice(0, options.leftDelimiter.length);\n      start = slice === options.leftDelimiter ? 0 : -1;\n      slice = str.slice(str.length - options.rightDelimiter.length);\n      end = slice === options.rightDelimiter ? str.length - options.rightDelimiter.length : -1;\n      break;\n    }\n\n    return start !== -1 && end !== -1 && validCurlyLength(str.substring(start, end + options.rightDelimiter.length));\n  };\n}\n\n/**\n * Removes last curly from string.\n */\nfunction removeDelimiter(str, options) {\n  const start = escapeRegExp(options.leftDelimiter);\n  const end = escapeRegExp(options.rightDelimiter);\n\n  let curly = new RegExp(\n    '[ \\\\n]?' + start + '[^' + start + end + ']+' + end + '$'\n  );\n  let pos = str.search(curly);\n\n  return pos !== -1 ? str.slice(0, pos) : str;\n}\n\n/**\n * Escapes special characters in string s such that the string\n * can be used in `new RegExp`. For example \"[\" becomes \"\\\\[\".\n *\n * @param {string} s Regex string.\n * @return {string} Escaped string.\n */\nfunction escapeRegExp(s) {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\n/**\n * find corresponding opening block\n */\nfunction getMatchingOpeningToken(tokens, i) {\n  if (tokens[i].type === 'softbreak') {\n    return false;\n  }\n  // non closing blocks, example img\n  if (tokens[i].nesting === 0) {\n    return tokens[i];\n  }\n\n  let level = tokens[i].level;\n  let type = tokens[i].type.replace('_close', '_open');\n\n  for (; i >= 0; --i) {\n    if (tokens[i].type === type && tokens[i].level === level) {\n      return tokens[i];\n    }\n  }\n  return false;\n}\n\n\n/**\n * from https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js\n */\nlet HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nlet HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nlet HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\n\nexport {\n  escapeHtml,\n  getMatchingOpeningToken,\n  escapeRegExp,\n  removeDelimiter,\n  hasDelimiters,\n  addAttrs,\n  getAttrs\n};\n","\nimport * as utils from './utils.js';\n\n/**\n * If a pattern matches the token stream,\n * then run transform.\n */\n\nfunction patternsConfig(options) {\n  const __hr = new RegExp('^ {0,3}[-*_]{3,} ?'\n                          + utils.escapeRegExp(options.leftDelimiter)\n                          + '[^' + utils.escapeRegExp(options.rightDelimiter) + ']');\n\n  return ([\n    {\n      /**\n       * ```python {.cls}\n       * for i in range(10):\n       *     print(i)\n       * ```\n       */\n      name: 'fenced code blocks',\n      tests: [\n        {\n          shift: 0,\n          block: true,\n          info: utils.hasDelimiters('end', options)\n        }\n      ],\n      transform: (tokens, i) => {\n        let token = tokens[i];\n        let start = token.info.lastIndexOf(options.leftDelimiter);\n        let attrs = utils.getAttrs(token.info, start, options);\n        utils.addAttrs(attrs, token);\n        token.info = utils.removeDelimiter(token.info, options);\n      }\n    }, {\n      /**\n       * bla `click()`{.c} ![](img.png){.d}\n       *\n       * differs from 'inline attributes' as it does\n       * not have a closing tag (nesting: -1)\n       */\n      name: 'inline nesting 0',\n      tests: [\n        {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              shift: -1,\n              type: (str) => str === 'image' || str === 'code_inline'\n            }, {\n              shift: 0,\n              type: 'text',\n              content: utils.hasDelimiters('start', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let endChar = token.content.indexOf(options.rightDelimiter);\n        let attrToken = tokens[i].children[j - 1];\n        let attrs = utils.getAttrs(token.content, 0, options);\n        utils.addAttrs(attrs, attrToken);\n        if (token.content.length === (endChar + options.rightDelimiter.length)) {\n          tokens[i].children.splice(j, 1);\n        } else {\n          token.content = token.content.slice(endChar + options.rightDelimiter.length);\n        }\n      }\n    }, {\n      /**\n       * | h1 |\n       * | -- |\n       * | c1 |\n       * {.c}\n       */\n      name: 'tables',\n      tests: [\n        {\n          // let this token be i, such that for-loop continues at\n          // next token after tokens.splice\n          shift: 0,\n          type: 'table_close'\n        }, {\n          shift: 1,\n          type: 'paragraph_open'\n        }, {\n          shift: 2,\n          type: 'inline',\n          content: utils.hasDelimiters('only', options)\n        }\n      ],\n      transform: (tokens, i) => {\n        let token = tokens[i + 2];\n        let tableOpen = utils.getMatchingOpeningToken(tokens, i);\n        let attrs = utils.getAttrs(token.content, 0, options);\n        // add attributes\n        utils.addAttrs(attrs, tableOpen);\n        // remove <p>{.c}</p>\n        tokens.splice(i + 1, 3);\n      }\n    }, {\n      /**\n       * *emphasis*{.with attrs=1}\n       */\n      name: 'inline attributes',\n      tests: [\n        {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              shift: -1,\n              nesting: -1  // closing inline tag, </em>{.a}\n            }, {\n              shift: 0,\n              type: 'text',\n              content: utils.hasDelimiters('start', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, 0, options);\n        let openingToken = utils.getMatchingOpeningToken(tokens[i].children, j - 1);\n        utils.addAttrs(attrs, openingToken);\n        token.content = content.slice(content.indexOf(options.rightDelimiter) + options.rightDelimiter.length);\n      }\n    }, {\n      /**\n       * - item\n       * {.a}\n       */\n      name: 'list softbreak',\n      tests: [\n        {\n          shift: -2,\n          type: 'list_item_open'\n        }, {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              position: -2,\n              type: 'softbreak'\n            }, {\n              position: -1,\n              type: 'text',\n              content: utils.hasDelimiters('only', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, 0, options);\n        let ii = i - 2;\n        while (tokens[ii - 1] &&\n          tokens[ii - 1].type !== 'ordered_list_open' &&\n          tokens[ii - 1].type !== 'bullet_list_open') { ii--; }\n        utils.addAttrs(attrs, tokens[ii - 1]);\n        tokens[i].children = tokens[i].children.slice(0, -2);\n      }\n    }, {\n      /**\n       * - nested list\n       *   - with double \\n\n       *   {.a} <-- apply to nested ul\n       *\n       * {.b} <-- apply to root <ul>\n       */\n      name: 'list double softbreak',\n      tests: [\n        {\n          // let this token be i = 0 so that we can erase\n          // the <p>{.a}</p> tokens below\n          shift: 0,\n          type: (str) =>\n            str === 'bullet_list_close' ||\n            str === 'ordered_list_close'\n        }, {\n          shift: 1,\n          type: 'paragraph_open'\n        }, {\n          shift: 2,\n          type: 'inline',\n          content: utils.hasDelimiters('only', options),\n          children: (arr) => arr.length === 1\n        }, {\n          shift: 3,\n          type: 'paragraph_close'\n        }\n      ],\n      transform: (tokens, i) => {\n        let token = tokens[i + 2];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, 0, options);\n        let openingToken = utils.getMatchingOpeningToken(tokens, i);\n        utils.addAttrs(attrs, openingToken);\n        tokens.splice(i + 1, 3);\n      }\n    }, {\n      /**\n       * - end of {.list-item}\n       */\n      name: 'list item end',\n      tests: [\n        {\n          shift: -2,\n          type: 'list_item_open'\n        }, {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              position: -1,\n              type: 'text',\n              content: utils.hasDelimiters('end', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, content.lastIndexOf(options.leftDelimiter), options);\n        utils.addAttrs(attrs, tokens[i - 2]);\n        let trimmed = content.slice(0, content.lastIndexOf(options.leftDelimiter));\n        token.content = last(trimmed) !== ' ' ?\n          trimmed : trimmed.slice(0, -1);\n      }\n    }, {\n      /**\n       * something with softbreak\n       * {.cls}\n       */\n      name: '\\n{.a} softbreak then curly in start',\n      tests: [\n        {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              position: -2,\n              type: 'softbreak'\n            }, {\n              position: -1,\n              type: 'text',\n              content: utils.hasDelimiters('only', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let attrs = utils.getAttrs(token.content, 0, options);\n        // find last closing tag\n        let ii = i + 1;\n        while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) { ii++; }\n        let openingToken = utils.getMatchingOpeningToken(tokens, ii);\n        utils.addAttrs(attrs, openingToken);\n        tokens[i].children = tokens[i].children.slice(0, -2);\n      }\n    }, {\n      /**\n       * horizontal rule --- {#id}\n       */\n      name: 'horizontal rule',\n      tests: [\n        {\n          shift: 0,\n          type: 'paragraph_open'\n        },\n        {\n          shift: 1,\n          type: 'inline',\n          children: (arr) => arr.length === 1,\n          content: (str) => str.match(__hr) !== null\n        },\n        {\n          shift: 2,\n          type: 'paragraph_close'\n        }\n      ],\n      transform: (tokens, i) => {\n        let token = tokens[i];\n        token.type = 'hr';\n        token.tag = 'hr';\n        token.nesting = 0;\n        let content = tokens[i + 1].content;\n        let start = content.lastIndexOf(options.leftDelimiter);\n        token.attrs = utils.getAttrs(content, start, options);\n        token.markup = content;\n        tokens.splice(i + 1, 2);\n      }\n    }, {\n      /**\n       * end of {.block}\n       */\n      name: 'end of block',\n      tests: [\n        {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              position: -1,\n              content: utils.hasDelimiters('end', options),\n              type: (t) => t !== 'code_inline'\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, content.lastIndexOf(options.leftDelimiter), options);\n        let ii = i + 1;\n        while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) { ii++; }\n        let openingToken = utils.getMatchingOpeningToken(tokens, ii);\n        utils.addAttrs(attrs, openingToken);\n        let trimmed = content.slice(0, content.lastIndexOf(options.leftDelimiter));\n        token.content = last(trimmed) !== ' ' ?\n          trimmed : trimmed.slice(0, -1);\n      }\n    }\n  ]);\n}\n\n// get last element of array or string\nfunction last(arr) {\n  return arr.slice(-1)[0];\n}\n\nexport default patternsConfig;\n","\nimport patternsConfig from './patterns.js';\n\nconst defaultOptions = {\n  leftDelimiter: '{',\n  rightDelimiter: '}',\n  allowedAttributes: [],\n  ignore: null            // callback(token)\n};\n\nfunction attributes(md, options_) {\n  let options = Object.assign({}, defaultOptions);\n  options = Object.assign(options, options_);\n\n  const patterns = patternsConfig(options);\n\n  function curlyAttrs(state) {\n    let tokens = state.tokens;\n\n    for (let i = 0; i < tokens.length; i++) {\n      for (let p = 0; p < patterns.length; p++) {\n        let pattern = patterns[p];\n        let j = null; // position of child with offset 0\n        let match = pattern.tests.every(t => {\n          let res = test(tokens, i, t, options);\n          if (res.j !== null) { j = res.j; }\n          return res.match;\n        });\n        if (match) {\n          pattern.transform(tokens, i, j);\n          if (pattern.name === 'inline attributes' || pattern.name === 'inline nesting 0') {\n            // retry, may be several inline attributes\n            p--;\n          }\n        }\n      }\n    }\n  }\n\n  md.core.ruler.after('inline', 'curly_attributes', curlyAttrs);\n}\n\n/**\n * Test if t matches token stream.\n *\n * @param {array} tokens\n * @param {number} i\n * @param {object} t Test to match.\n * @return {object} { match: true|false, j: null|number }\n */\nfunction test(tokens, i, t, options) {\n  let res = {\n    match: false,\n    j: null  // position of child\n  };\n\n  let ii = t.shift !== undefined\n    ? i + t.shift\n    : t.position;\n  let token = get(tokens, ii);  // supports negative ii\n\n  // supports ignore token\n  if (token === undefined || (options.ignore && options.ignore(token))) {\n    return res;\n  }\n\n  for (let key in t) {\n    if (key === 'shift' || key === 'position') { continue; }\n\n    if (token[key] === undefined) { return res; }\n\n    if (key === 'children' && isArrayOfObjects(t.children)) {\n      if (token.children.length === 0) {\n        return res;\n      }\n      let match;\n      let childTests = t.children;\n      let children = token.children;\n      if (childTests.every(tt => tt.position !== undefined)) {\n        // positions instead of shifts, do not loop all children\n        match = childTests.every(tt => test(children, tt.position, tt, options).match);\n        if (match) {\n          // we may need position of child in transform\n          let j = last(childTests).position;\n          res.j = j >= 0 ? j : children.length + j;\n        }\n      } else {\n        for (let j = 0; j < children.length; j++) {\n          match = childTests.every(tt => test(children, j, tt, options).match);\n          if (match) {\n            res.j = j;\n            // all tests true, continue with next key of pattern t\n            break;\n          }\n        }\n      }\n\n      if (match === false) { return res; }\n\n      continue;\n    }\n\n    switch (typeof t[key]) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      if (token[key] !== t[key]) { return res; }\n      break;\n    case 'function':\n      if (!t[key](token[key])) { return res; }\n      break;\n    case 'object':\n      if (isArrayOfFunctions(t[key])) {\n        let r = t[key].every(tt => tt(token[key]));\n        if (r === false) { return res; }\n        break;\n      }\n    // fall through for objects !== arrays of functions\n    default:\n      throw new Error(`Unknown type of pattern test (key: ${key}). Test should be of type boolean, number, string, function or array of functions.`);\n    }\n  }\n\n  // no tests returned false -> all tests returns true\n  res.match = true;\n  return res;\n}\n\nfunction isArrayOfObjects(arr) {\n  return Array.isArray(arr) && arr.length && arr.every(i => typeof i === 'object');\n}\n\nfunction isArrayOfFunctions(arr) {\n  return Array.isArray(arr) && arr.length && arr.every(i => typeof i === 'function');\n}\n\n/**\n * Get n item of array. Supports negative n, where -1 is last\n * element in array.\n * @param {array} arr\n * @param {number} n\n */\nfunction get(arr, n) {\n  return n >= 0 ? arr[n] : arr[arr.length + n];\n}\n\n// get last element of array, safe - returns {} if not found\nfunction last(arr) {\n  return arr.slice(-1)[0] || {};\n}\n\n//module.exports = attributes;\nexport default attributes;\n\n"],"names":["getAttrs","str","start","options","allowedKeyChars","pairSeparator","keySeparator","classChar","idChar","attrs","key","value","parsingKey","valueInsideQuotes","i","leftDelimiter","length","slice","rightDelimiter","push","char_","charAt","search","allowedAttributes","filter","attrPair","attr","isAllowedAttribute","allowedAttribute","RegExp","test","some","addAttrs","token","j","l","attrJoin","attrPush","hasDelimiters","where","Error","minCurlyLength","validCurlyLength","curly","isClass","isId","end","nextChar","rightDelimiterMinimumShift","indexOf","lastIndexOf","substring","removeDelimiter","escapeRegExp","pos","s","replace","getMatchingOpeningToken","tokens","type","nesting","level","patternsConfig","__hr","utils","name","tests","shift","block","info","transform","children","content","endChar","attrToken","splice","tableOpen","openingToken","position","ii","arr","trimmed","last","match","tag","markup","t","defaultOptions","ignore","attributes","md","options_","Object","assign","patterns","curlyAttrs","state","p","pattern","every","res","core","ruler","after","undefined","get","isArrayOfObjects","childTests","tt","isArrayOfFunctions","r","Array","isArray","n"],"mappings":"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"}